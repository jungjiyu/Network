이상준 010-2333-2967 
이멜 ; lsj750811@naver.com

별하나 >> 빈도수 낮지만 중요
별3개>> 시험에 잘 나오고 중요
별5개>> 실무에도 쓰이고 시험에 잘나오고 중요

192.168.41.71

NIC 는 입출력장치이다.
입력받은 걸 CPU 에게 전달하면 CPU가 연산하는거다

MAC Media Access Control 주소
	: 네트워크 연결되는 장비들이 가지는 "고유한" 주소
	: 물리적 주소
	: 구성
		앞의 24비트) OUI
			: 어느 회사에서 생산했는지 나타냄
			
		뒤의 24비트: Host identifier
			: 회사에서 제품에 부여하는 시리얼 넘버

IP internet Protocol 주소
	: 논리적 주소



통신방식 따른 네트워크 분류
	(1) 유니캐스트 Unicast
		: 일대일 전달 방식
	

	(2) 브로드캐스트 Broadcast
		: 일대 "전체" 전달 방식
			: 전체== 동일 네트워크에 연결된 "모든" 네트워크 장비들==  BroadCast Doamin 안의 모든 장비들


	(3) 멀티캐스트 Multicast
		: 일대 특정 그룹 전달 방식
		

ARP Address Resolution Protocol
	: IP 와 MAC 주소를 서로 매핑하는 절차. 그러니까 상대편의 MAC 어드레스를 알기 위해서 하는 동작.
		: 일반적으로 IP 주소만을 보기 때문에 IP 주소로만 통신을 생각하지만 IP 를 MAC 으로 바꾸는 절차를 거친다. 
	:  how 작동
		: 브로드캐스트 + 유니케스트방식
		: 네트워크 내의 컴퓨터에게 이 IP 주소를 가진 컴퓨터가 누군지 불특정 다수에게 물어보면 그 IP 주소를 가진 컴터가 자신이라고 답을 자신의 MAC 어드레스와 함께 콕 찝어서 보내는 방식.
			

		: 라우터가 있다 >> 서로 다른 네트워크다.(라우터는 LAN 과 LAN 을 연결해서 WAN 만드는 얘니까)	
			: 라우터에게 arp 를 하면 라우터가 다른 네트워크에 있는 얘한테 
			: 라우터는 브로드캐스트 기능은 없어서 브로드캐스트는 못한다.
	: cisco		
		: realtime == 실시간
		: 실습
			: 컴터 4개 & 스위치 하나꺼냄
			: 각 컴터를 스위치에 automatic connection 으로 연결
			: 각 컴터 눌러서 ip 를 설정하고(192.168.0.X) , 서브넷 마스크도 설정(서브넷 마스크는 ip 설정하고 필드 클릭함 자동 생성됨)
			: real time 뒤에있는 얘 누르고 show alone 버튼 누름&& edit filters 에서 arp 랑 icmp 체크
				: ICMP Internet Control Message Protocol
					; ip 는 신뢰성을 제공하지 않는 프로토콜이다(=데이터를 잘 받았다고 받는쪽에서 따로 응답을 안한다). 그래서 목적지 대상장치와의 통신 여부를 확인하기 위한 프로토콜이 icmp이다
					: 유니캐스트 방식이다 << 1: 1 통신이다
					: ping 이라는 유틸리티를 사용하는게 특징이며 주로 메세지 혀ㅇ태도 통신상태 여부를 확인할 수 있다.
						: 예 ) ping 192.168.0.3 // 4회 왕복
							ping 192.168.0.3 -t // 무한 왕복
			: pc2 - desktop-command Prompt
				: ping 대상컴터의ip주소 입력

			: simulation panel 탭에서 arp 테이블 확인 가능
				: src ip == 자기 자신꺼
				: dst ip == ping 보낸 대상컴터의ip주소
				: 자기 자신의 mac address 실는다
				: 목적지 mac address 는 모르니 0000000000 으로 채워서 보낸다
				: 자신의 ip 와 mac address 가 아니면 무시한다

			: simulation 탭의 capture/forward 버튼 클릭 
				: 각 과정의 패킷 내용은 메세지 이모티콘 누름확인 가능
					: ARP 테이블 == 초록색 계열 메세지 이모티콘
					: ICMP 테이블 == 파란색 혹은 보라색  메세지 이모티콘
				: 다음 단계로 진행시킴
					0. PC0에서 ICMP 와 ARP 준비만 한 상태
						: ARP 테이블 (초록색 계열 메세지 이모티콘)의 
							:ARP 부분 확인해보면 SOURCE MAC 은 명시가 되있지만 TARGET MAC 은 0000.0000.0000 으로 되어있음 (DEST IP 는 물론 잘 명시되있음)
								: 자신의 MAC address 는 당연히 자신이 알고, DEST 의 ip는 알아도 MAC 은 모르는 상황이기 때문
								: Target MAC == DEST MAC

							: EthernetII 부분을 확인해보면 SRC MAC 은 제대로 나와있지만 DEST MAC 은 FFFF.FFFF.FFFF 로 되어있음
						: ICMP 메세지가 파란색

					1. 라우터까지 ARP 전송
						: ARP 테이블의 내용은 0단계와 다를게 없음
						: 라우터의 메세지 이모티콘이 x 표시와 함꼐 표시됨

					2. 라우터에서 pc0 으로 ICMP를 보냄
						: ARP 테이블의 내용은 0단계와 다를게 없음
						: pc0의 메세지 이모티콘이 x 표시와 함께 표시됨
							: 그러니까 아직 대상 pc 가 arp 에 등록 안되어있단 소리임

					3. pc0에서 ICMP와 ARP 가 새로 생김
						: ARP 테이블의 내용은 0단계와 다를게 없음
						: ICMP 가 보라색

					4. 라우터까지 ARP 전송
						: 이번엔 x표시 없이 잘 보내짐

					5. 라우터에서 브로드캐스트로 pc1, pc2, pc3 에게 ARP 전송
						: 대상 pc 엔 온전한 메세지 이모티콘이 뜨고(=제대로 보내지고), 나머지 pc엔 x자와 함께 메세지 이모티콘 표시됨
						: 아직까지도 arp 테이블 내용 안변함

					6. 대상 pc 에서 라우터로 arp 전송
						: arp 테이블에 대상 pc 의 MAC 주소가 추가됨

					7. 라우터에서 pc0으로 arp 를 보냄
					8. pc0에 arp 가 도착하고 icmp 새로 생김
					9. PC0에서 라우터로 icmp 전송
					10. 라우터에서 유니캐스트로 대상 pc에게 icmp 전송
					11. 대상 pc서 라우터로 icmp 전송
					12. 라우터에서 pc0 으로 icmp전송 , pc0에선 새로은 icmp생성됨


			: 광클함 렉걸리니 주의
			
			: 다시 pc0의 프롬프트 창에서 
				: arp -a
					: arp 테이블 목록 확인 명령어
					: pc 의 RAM 에 저장됨 (저장 수명은 300 초) - 운영체제마다 다름 또는 통신 장비에서 별도로 세팅 가능함 
						: 그러니까 5분 지나면 메모리 상에서 자연스럽게 소멸된다
							: 5분 지나도 메모리 상에서 안없어지는건ㄴ 통신 장비에서 저장 수명을 수정해논거다
					: dynamic 동적 >> 프로토콜에 의해 자동으로 진행되는 것
						: 반대되는 개념 static >> 직접 진행하는 것
						: 문제점 ) 콜센터와 같이 pc 가 3,400 대 정도 되는 경우 과도한 broadcast 가 일어남
							: 과도한 broadcast 를 방지하는 법 >> static 으로 설정

				: arp -s 대상컴터의아이피 대상컴터의맥어드래스
					: arp 테이블을 수동으로 작성하여 저장하는 명령어 
						: 단 , 패킷 트레이서 에서는 지원되지 않는 명령어 . 패킷트레이서가 진짜 pc 수준으로 정밀하게 만든ㄴ 프로그램이 아니라서 그렇다
					: 옵션의 s 는 static 의 s 인거임

					: 문제점 ) pc는 영구 장치가 아니다.
						: pc 를 교체하는 경우 arp 리스트에 등록된 pc를 삭제해줘야된다.

					: arp 이후 일부 장비의 교체로 인한 통신불가 상태 처리 방법
						sol1. 5분 이상을 재통신 없이 기다린다 << 자동적으로 메모리 상에서 없어지길 기다린다
							: 희박하다. 설정 따라서 5분이상 메모리에 남아있을 수 있기 떄문
						sol2.  arp 테이블을 수동삭제(arp -d) 후 arp를 다시 진행
							: 실무에서 가장 많이 사용하는 방법
							: 근데 패킷트레이서에선 이 명령어 지원 안해줘서 실습에선 사용 못한다

						sol3. 재부팅하면 arp 테이블은 dynamic 인 경우 모두 소멸되므로 arp 를 다시 진행
							: RAM 은 휘발성이라 전원을 껐따 키면 모든 메모리가 소멸되는거다
							: 서버의 경우 계속 서버가 가동중이어야 되는데 , 재부팅의 경우 서비스가 중단이됨, 서버가 다운됨. 
								: 카카오톡만해도 연관된 서비스가 ㅈㄴ 많기  때문에 5분만 다운되도 좆된다


				: arp -d 대상컴터의아이피 
					: arp목록에서 특정ip에 대한 arp를 삭제하는 명령어
					: 얘도 패킷트레이서에선 지원 안되는 명령어
					: IP 하나에 MAC 어드레스 하나만 매핑되어있는거라 별도로 mac 어드레스까지 입력할 필요가 없는 것


		: pc2 를 삭제함
		: 새로운 pc2를 생성(이전 pc2에 할당했던 ip랑 똑같은 ip를 부여)
		: pc0에서 pc2 에 ping 보내기 시도 >> 안됨
			: arp 리스트에 등록되있던 ip주소와 맵핑된 MAC 주소가 다르기 때문이다

		: pc0 - physical 화면에서 빨간색 동글뱅이 버튼 한번 누르고 또 누름
			:pc0을 재부팅하는것
			: arp 이후 장비 교체 상황에서 그 교체를 반영한 새 arp 를 형성하기 위함

		: 공부 tip
			: win + shift + s  >> 캡쳐
			: 윈도우에 기본적으로 깔려있는 워드패드에 해당 캡쳐사진 붙여넣는다
				: 워드패드는 일반 메모장과 다르게 사진까지 저장할 수 있어서 좋다
신뢰성을 보장하지 않는다 == 목적지에서 받았다 못받았다 답장 안한다
		
		: ping 메세지 TTL 값으로 알 수 있는 두가지
			: 일단 TTL Time to Live
				: 패킷이 라우터에 의해 폐기될 때까지 네트워크 내부에 존재하도록 설정된 데이터의 유효기간
				: 그러니까 답장 받기까지 걸린 시간
			: 알 수있는 두가지
				1. 운영체제
					window-128 이하
					unix(리눅수 , mac) - 64 이하

				2. 홉 카운트 << 그러니까 몇개의 라우터를 경유하였는가
					: 홉 ) 라우터를 1개 경유하는 단위
					한 홉마다(라우터를 1개(를) 경유시마다) -1 씩 차감됨

			: cmd 창에서 확인해보기 
				ping 구글도메인네임 
					: TTL=112
						: 일단 64 초과니까 window 계열 
						:  128-112 == 16 홉 . 근데 찐으로 16 홉은 아니다 << 찐은 아래의 tarcert (트레이스 rt) 명령어로 확인한다

				tracert 구글도메인네임
					: 경로 추적하는것
					: 컴터마다 구글 주소의 ip가 다르게 나올 수 있다
						: 왜>> 여러대의 서버가 존재 : 도메인 네임 을 DNS 에 질의했을때 그게 매번 똑같은 ip주소를 전달해주는게 아니라 ( 똑같은 서버에 배정되는게 아니라) 부하분산서비스. 라운드 로빙. 에 의해 주소가 바뀌어서 전달되는거다
			
					: (ping 과는 다르게)14대가 나오는 이유 >> 보안 처리가 되있어서 ip 가 ㅇ안나오는 것들은 카운트가 안될거임. 지금 우린 LAN 상황. 대부분 공유기(=게이트웨이) 를 거쳐서 나감. 그래서 이것까지 카운트 함 안딤. 그래서 실제로는 

				: 비교
					경로추적 >> 디테일한 경로 추적
						: 보안처리 되어 생략된것까지 나온다
					ping >> 대략적인 경로 추적
						: 보안처리 된 것 등은 카운트 안한다

			: 300 대 가까이 되는 경우도 많다(콜센터)

주식 투자하면 트렌드를 읽을 수 있다
-

OSI 7 layer, TCP/IP 모델 비교
	: 공통점 >> 둘다 계층형이다
	: 차이점 
		>> 각 계층이 서로 상이하다
		>> OSI 7 layer 는 가이드 역할로 충실하지만 실제 구현의 예가 거의 없어 신뢰도가 약하다
		>> TCP/IP 모델은 인터넷 개발 이후 계속 표준. 수십년간 ㅇ운용 경험에 의해 신뢰도가 높다

TCP/IP 참조 모델
	: 인터넷의 전반적 과정을 다룬 모델
	: OSI 7 Layer 보다 더 먼저 나온 현재에도 가장 범용적으로 사용하는 모델이다
	: OSI 7 Layer 모델이랑 분명히 다른 거
	: 계층
		1계층 Network Interface
			: OSI 7 layer 의 Phisycal Layer, Data Link Layer 에 해당
		2계층 Internet Layer
			: OSI 7 layer 의 Network Layer 에 해당
		3계층 Transport Layer
			: OSI 7 layer 의 Transport Layer 에 해당
		4계층 Application Layer
			: OSI 7 Layer 의 Session Layer , Presentation Layer, Application Layer 에 해당

OSI 7 Layer 모델
	: 통신이 일어나는 과정을 전반적으로 다룬 모델
	: 국제 표준화 기구(ISO)가 1984년에 발표
	: 왜 굳이 나눴나>> (전체적으로 보수하는게 아니라)단계별로 소프트웨러를 보수 가능+흐름파악용이
		: 볶음밥의 재료도 순서를 지켜 볶아야된다													
																		
	: 계층
		1계층 - Physical Layer 물리계층
			:  전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 계층(물리적 장비)
			: 단지 데이터를 전달"만" 하고 받으려는 데이터에 대한 에러에 대한 검사는 안함
			: 단위) 비트 단위(= 0 , 1 로 나타나진다 = 전기적으로 on off 다)
			: 대표 장비) 통신케이블,리피터, 허브


		2계층 - Data Link Layer 데이터 링크 계층
			: 물리계층을 통해 송수신되는 데이터의 오류와 흐름을 관리하여 신뢰성 제공 계층
			: 단위 )프레임
				: 2 계층에서 데이터를 전달하는 단위를 걍 프레임이라 함
				: 프레임 단위로 MAC 주소를 부여하여 통신
			: 대표 장비) 브릿지, 스위치, 이더넷

		3계층-네트워크 계층 Network Layer
			: 데이터를 목적지까지 최대한 안전하고 빠르게 전달하는 계층
				: IP담당 + 라우팅기능(여러개의 노드를 거칠때마다 경로를 찾아줌)
			: 단위) 패킷 packet 
				: 3계층에서 데이터를 전달하는 단위를 걍 패킷이라고 함
			: 대표장비) 라우터

		4계층-전송개충 Transport Layer
			: 정보를 분할하고, 상대편에 도달하기 전에 다시 합치는 과정을 담당
				: port 번호와 전송방식(TCP || UDP) 결정 하여 TCP 헤더를 붙여서 두 지점간의 신뢰성 있는 데이터를 주고 받게 함
			: 
			: 4계층 프로토콜) TCP , UDP
				: TCP >> 신뢰성, 연결지향적
				: UDP >> 비신뢰성, 비연결성, 실시간
 
		5계층- 세션 계층 Session Layer
			: TCP/IP 세션을 체결, 포트 번호를 기반으로 통신 세션을 구성
				: 주 지점간의 프러세스 및 통신하는 호스트 간의 연결 유지
			: API, Sokcet
		
		6계층-표현계층 Presentation Layer
			: 전송하는 데이터의 표현 방식(데이터변ㄴ환 압축 암호화등)을 결정
			: JPG , GIF, ASCII 등

		7계층-응용계층 Application Layer
			: 최종 목적지. 응용 프로세스와 직접 관계하여 일반적인 응용 서비스르 수행(explore, chrome)
			: 대표 프로토콜) HTTP , FTP, IMAP 등




시스코가 하도 갑질해대서(우리 장비만 써서 해라) 한때 탈시스코 붐이 일어났다
